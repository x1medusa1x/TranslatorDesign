/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, UMINUS, CHAR,
					TIMES, LPAREN, RPAREN, CLASS,
					PUBLIC, PRIVATE, INT, COLON, EQUAL,
					FLOAT, DOUBLE, STR, PROTECTED, CLPAREN, CRPAREN,
					STATIC, COMMA, NAMESPACE, DEFINE, INCLUDE, ASM, AUTO, 
					BREAK, CASE, CATCH, CONST, CONTINUE, DEFAULT, 
					DELETE, DO, ELSE, ENUM, EXTERN, FOR, FRIEND, 
					GOTO, IF, INLINE, LONG, NEW, OPERATOR, REGISTER, 
					RETURN, SHORT, SIGNED, SIZEOF, STRUCT, 
					SWITCH, TEMPLATE, THIS, THROW, TRY, TYPEDEF, UNION, 
					UNSIGNED, VIRTUAL, VOID, VOLATILE, WHILE, LEFTSHIFT, 
					RIGHTSHIFT, XOR, AND, OR, SMALLERTHAN, GREATERTHAN, IDENT;
terminal Integer    NUMBER;        // our scanner provides numbers as integers
terminal String     STRING;       // our scanner provides numbers as integers

/* Non terminals */
non terminal            expr_list;
non terminal Integer    expr;      // used to store evaluated subexpressions
non terminal            exprString;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left UMINUS;

/* The grammar rules */
expr_list ::= expr_list expr:e SEMI         {: System.out.println(e); :}
            | expr:e SEMI                   {: System.out.println(e); :}
            | exprString: e                    {: System.out.println(e); :}
            | expr_list exprString:e           {: System.out.println(e); :}
            | expr_list:e SEMI              {: System.out.println(e); :}
            | expr_list:e COMMA             {: System.out.println(e); :}
            ;
            
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;        :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;        :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;        :}
             | MINUS expr:e                 {: RESULT = -e;           :}
             %prec UMINUS
             | LPAREN expr:e RPAREN	         {: RESULT = e;           :}
             | NUMBER:n	                      {: RESULT = n;           :}
             ;
    
exprString ::=   CLASS IDENT:e             {: RESULT = e; :}
			| IDENT:e                      {: RESULT = "ceva_" + e; :}
			| CLASS IDENT:str CLPAREN expr_list:e CRPAREN    {: RESULT = "" + e + " in class " + str ; :}
		   	| PUBLIC INT IDENT:e2 SEMI     {: RESULT = "public variable " + e2 + " of type int"; :}
		   	| PUBLIC CHAR IDENT:e2 SEMI      {: RESULT = "public variable " + e2 + " of type char"; :}
		   	| PUBLIC STR IDENT:e2 SEMI     {: RESULT = "public variable " + e2 + " of type string"; :}
		   	| PUBLIC FLOAT IDENT:e2 SEMI   {: RESULT = "public variable " + e2 + " of type float"; :}
		   	| PUBLIC DOUBLE IDENT:e2 SEMI  {: RESULT = "public variable " + e2 + " of type double"; :}
		   	| INT IDENT:e SEMI             {: RESULT = "non-static int variable " + e; :}
			| CHAR IDENT:e SEMI              {: RESULT = "non-static char variable " + e; :}
			| STR IDENT:e SEMI             {: RESULT = "non-static string variable " + e; :}
			| DOUBLE IDENT:e SEMI          {: RESULT = "non-static double variable " + e; :}
			| FLOAT IDENT:e SEMI           {: RESULT = "non-static float variable " + e; :}
			| LONG IDENT:e SEMI            {: RESULT = "non-static long variable " + e; :} 
			;
			