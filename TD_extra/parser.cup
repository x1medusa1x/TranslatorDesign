/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {::=return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, UMINUS, CHAR,
					TIMES, LPAREN, RPAREN, CLASS,
					PUBLIC, PRIVATE, INT, COLON, EQUAL,
					FLOAT, DOUBLE, STR, PROTECTED, CLPAREN, CRPAREN,
					STATIC, COMMA, NAMESPACE, DEFINE, INCLUDE, ASM, AUTO, 
					BREAK, CASE, CATCH, CONST, CONTINUE, DEFAULT, 
					DELETE, DO, ELSE, ENUM, EXTERN, FOR, FRIEND, 
					GOTO, IF, INLINE, LONG, NEW, OPERATOR, REGISTER, 
					RETURN, SHORT, SIGNED, SIZEOF, STRUCT, 
					SWITCH, TEMPLATE, THIS, THROW, TRY, TYPEDEF, UNION, 
					UNSIGNED, VIRTUAL, VOID, VOLATILE, WHILE, LEFTSHIFT, 
					RIGHTSHIFT, XOR, AND, OR, SMALLERTHAN, GREATERTHAN, IDENT, SCOPE,
                    ELLIPSIS, EQ, NE, LE, GE, LOG_AND, LOG_OR, INC, DEC, ARROW_STAR, 
                    ARROW, DOT_START, ASS_ADD, ASS_SUB, ASS_MUL, ASS_DIV, ASS_MOD, 
                    ASS_XOR, ASS_AND, ASS_OR, ASS_SHR, ASS_SHL, CHARACTER, STRNG, ESCAPED, 
                    FALSE, TRUE, SQLPAREN, SQRPAREN, SQUIGLY, DOT, TYPEID, TYPENAME, DOT_STAR,
                    DYNAMICCAST, STATICCAST, REINTERPRETCAST, CONSTCAST, ESC, PERCENT, DIVIDE,
                    QM, HASHT, MUTABLE, EXPLICIT, BOOLEAN, USING, EXPORT;
                    
terminal Integer    NUMBER, PPNUMBER;        // our scanner provides numbers as integers
terminal String     STRING;       // our scanner provides numbers as integers

/* Non terminals */
non terminal identifier_word, identifier, id, template_test, global_scope, id_scope, nested_id, scoped_id, destructor_id, special_function_id, nested_special_function_id, scoped_special_function_id,
declarator_id, built_in_type_id, pseudo_destructor_id, nested_pseudo_destructor_id, scoped_pseudo_destructor_id, string, 
literal, boolean_literal, translation_unit, primary_expression, abstract_expression, type1_parameters, mark_type1,
postfix_expression, expression_list, unary_expression, delete_expression, new_expression, 
new_type_id, new_declarator, direct_new_declarator, cast_expression, pm_expression, multiplicative_expression, additive_expression,
shift_expressionr, elational_expression, equality_expression, and_expression, exclusive_or_expression, inclusive_or_expression, 
logical_and_expression, logical_or_expression, conditional_expression, assignment_expression, assignment_operator, expression,
constant_expression, templated_relational_expression, templated_equality_expression, templated_and_expression, templated_exclusive_or_expression,
templated_inclusive_or_expression, templated_logical_and_expression, templated_logical_or_expression, templated_conditional_expression, templated_assignment_expression,
templated_expression, templated_expression_list, looping_statement, looped_statement, statement, control_statement, labeled_statement, compound_statement,
selection_statement, condition, iteration_statement, for_init_statement, jump_statement, declaration_statement, compound_declaration,
looping_declaration, looped_declaration, declaration, specialised_declaration, block_declaration, specialised_block_declaration, simple_declaration,
suffix_built_in_decl_specifier, suffix_named_decl_specifier, suffix_named_decl_specifiers,
suffix_decl_specified_ids, suffix_decl_specified_scope, decl_specifier_affix, decl_specifier_suffix, decl_specifier_prefix, storage_class_specifier, function_specifier,
type_specifier, elaborate_type_specifier, simple_type_specifier, built_in_type_specifier, elaborated_type_specifier, elaborated_enum_specifier, enum_specifier, enumerator_clause,
enumerator_list_ecarb, enumerator_definition_ecarb, enumerator_definition_filler, enumerator_list_head, enumerator_list, enumerator_definition, enumerator, namespace_definition,
namespace_alias_definition, using_declaration, using_directive, asm_definition, linkage_specification, init_declarations, init_declaration, star_ptr_operator, nested_ptr_operator,
ptr_operator, ptr_operator_seq, cv_qualifier, type_id,  direct_abstract_declarator, shift_expression, relational_expression,
parenthesis_clause, parameters_clause, parameter_declaration_clause, parameter_declaration_list, abstract_pointer_declaration, abstract_parameter_declaration, special_parameter_declaration,
parameter_declaration, templated_parameter_declaration, templated_abstract_declaration, function_definition, func_definition, ctor_definition, constructor_head, function_try_block,
function_block, function_body, initializer_clause, braced_initializer, initializer_list, looping_initializer_clause, looped_initializer_clause, colon_mark, elaborated_class_specifier,
class_specifier_head, class_key, class_specifier, looping_member_declaration, looped_member_declaration, member_declaration, simple_member_declaration, member_init_declarations,
member_init_declaration, accessibility_specifier, bit_field_declaration, bit_field_width, bit_field_init_declaration, base_specifier_list, base_specifier, access_specifier, conversion_function_id, 
conversion_type_id, ctor_initializer, mem_initializer_list, mem_initializer_list_head, mem_initializer, mem_initializer_id, operator_function_id, operator, template_declaration,
template_parameter_clause, template_parameter_list, template_parameter, simple_type_parameter, templated_type_parameter, template_id, template_argument_list, template_argument, explicit_specialization,
try_block, handler_seq, handler, exception_declaration, throw_expression, templated_throw_expression, exception_specification, type_id_list, advance_search, bang, mark, nest, start_search, start_search1, util,
new_initializer_opt, ptr_operator_seq_opt, expression_list_opt, expression_opt, statement_seq_opt, condition_opt, declaration_seq_opt, cv_qualifier_seq_opt, abstract_declarator_opt, direct_abstract_declarator_opt,
suffix_built_in_decl_specifier_raw, suffix_named_decl_specifier_bi, suffix_named_decl_specifiers_sf, ctor_initializer_opt, member_specification_opt, expr, expr_list, exprString;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left UMINUS;

/* The grammar rules */
/*
expr_list ::= expr_list expr:e SEMI         {::=System.out.println(e); :}
            | expr:e SEMI                   {::=System.out.println(e); :}
            | exprString:e                    {::=System.out.println(e); :}
            | expr_list exprString:e           {::=System.out.println(e); :}
            | expr_list:e SEMI              {::=System.out.println(e); :}
            | expr_list:e COMMA             {::=System.out.println(e); :}
            ;
            
expr      ::= expr:e1 PLUS  expr:e2         {::=RESULT = e1+e2;        :}
             | expr:e1 MINUS expr:e2        {::=RESULT = e1-e2;        :}
             | expr:e1 TIMES expr:e2        {::=RESULT = e1*e2;        :}
             | MINUS expr:e                 {::=RESULT = -e;           :}
             %prec UMINUS
             | LPAREN expr:e RPAREN	         {::=RESULT = e;           :}
             | NUMBER:n	                      {::=RESULT = n;           :}
             ;
    
exprString ::=   CLASS IDENT:e             {::=RESULT = e; :}
			| IDENT:e                      {::=RESULT = "ceva_" + e; :}
			| CLASS IDENT:str CLPAREN expr_list:e CRPAREN    {::=RESULT = "" + e + " in class " + str ; :}
		   	| PUBLIC INT IDENT:e2 SEMI     {::=RESULT = "public variable " + e2 + " of type int"; :}
		   	| PUBLIC CHAR IDENT:e2 SEMI      {::=RESULT = "public variable " + e2 + " of type char"; :}
		   	| PUBLIC STR IDENT:e2 SEMI     {::=RESULT = "public variable " + e2 + " of type string"; :}
		   	| PUBLIC FLOAT IDENT:e2 SEMI   {::=RESULT = "public variable " + e2 + " of type float"; :}
		   	| PUBLIC DOUBLE IDENT:e2 SEMI  {::=RESULT = "public variable " + e2 + " of type double"; :}
		   	| INT IDENT:e SEMI             {::=RESULT = "non-static int variable " + e; :}
			| CHAR IDENT:e SEMI              {::=RESULT = "non-static char variable " + e; :}
			| STR IDENT:e SEMI             {::=RESULT = "non-static string variable " + e; :}
			| DOUBLE IDENT:e SEMI          {::=RESULT = "non-static double variable " + e; :}
			| FLOAT IDENT:e SEMI           {::=RESULT = "non-static float variable " + e; :}
			| LONG IDENT:e SEMI            {::=RESULT = "non-static long variable " + e; :} 
			;
			
			*/

    
identifier::=                       IDENT;
id::=                               identifier SMALLERTHAN PLUS template_argument_list GREATERTHAN
    |                               identifier SMALLERTHAN MINUS
    |                               template_id;


global_scope::=                     SCOPE
    |                               TEMPLATE global_scope;
id_scope::=                         id SCOPE;

nested_id::=                        id 
    |							    id_scope nested_id;

scoped_id::=                        nested_id
    |                               global_scope nested_id;

destructor_id::=                    SQUIGLY id
    |                               TEMPLATE destructor_id;
special_function_id::=                conversion_function_id
    |                               operator_function_id
    |                               TEMPLATE special_function_id;
nested_special_function_id::=       special_function_id
    |                               id_scope destructor_id
    |                               id_scope nested_special_function_id;
scoped_special_function_id::=       nested_special_function_id
    |                               global_scope nested_special_function_id;

declarator_id::=                    scoped_id
    |                               scoped_special_function_id
    |                               destructor_id;

built_in_type_id::=                 built_in_type_specifier
    |                               built_in_type_id built_in_type_specifier;
pseudo_destructor_id::=             built_in_type_id SCOPE SQUIGLY built_in_type_id
    |                               SQUIGLY built_in_type_id
    |                               TEMPLATE pseudo_destructor_id;
nested_pseudo_destructor_id::=      pseudo_destructor_id
    |                               id_scope nested_pseudo_destructor_id;
scoped_pseudo_destructor_id::=      nested_pseudo_destructor_id
    |                               global_scope scoped_pseudo_destructor_id;

string::=                           STRNG;
literal::=                          INT
    |                               CHARACTER
    |                               FLOAT
    |                               string
    |                               boolean_literal;
    
boolean_literal::=                  FALSE
    |                               TRUE;

translation_unit::=                 declaration_seq_opt;

primary_expression::=               literal
    |                               THIS
    |                               suffix_decl_specified_ids
    |                               abstract_expression;
    
abstract_expression::=              parenthesis_clause
    |                               SQLPAREN expression_opt SQRPAREN
    |                               TEMPLATE abstract_expression;

type1_parameters::=                 parameter_declaration_list SEMI
    |                               type1_parameters parameter_declaration_list SEMI;
/*mark_type1::=                                                                   { mark_type1(); yyclearin; }*/
postfix_expression::=               primary_expression
    |                   /*----*/    postfix_expression parenthesis_clause mark_type1 MINUS
    |                   /*----*/    postfix_expression parenthesis_clause mark_type1 PLUS type1_parameters mark CLPAREN error 
                        /*----*/                    /*{ yyerrok; yyclearin; remark_type1(); unmark(); unmark(); }*/
    |                   /*----*/    postfix_expression parenthesis_clause mark_type1 PLUS type1_parameters mark error 
                        /*----*/                    /*{ yyerrok; yyclearin; remark_type1(); unmark(); unmark(); }*/
    |                   /*----*/    postfix_expression parenthesis_clause mark_type1 PLUS error
                        /*----*/                    /*{ yyerrok; yyclearin; remark_type1(); unmark(); }*/
    |                               postfix_expression SQLPAREN expression SQRPAREN
    |                               postfix_expression DOT declarator_id
    |                               postfix_expression DOT scoped_pseudo_destructor_id
    |                               postfix_expression ARROW declarator_id
    |                               postfix_expression ARROW scoped_pseudo_destructor_id   
    |                               postfix_expression INC
    |                               postfix_expression DEC
    |                               DYNAMICCAST SMALLERTHAN type_id GREATERTHAN LPAREN expression RPAREN
    |                               STATICCAST SMALLERTHAN type_id GREATERTHAN LPAREN expression RPAREN
    |                               REINTERPRETCAST SMALLERTHAN type_id GREATERTHAN LPAREN expression RPAREN
    |                               CONSTCAST SMALLERTHAN type_id GREATERTHAN LPAREN expression RPAREN
    |                               TYPEID parameters_clause;

expression_list_opt::=              /* empty */
    |                               expression_list;

expression_list::=                  assignment_expression
    |                               expression_list COMMA assignment_expression;

unary_expression::=                 postfix_expression
    |                               INC cast_expression
    |                               DEC cast_expression
    |                               ptr_operator cast_expression
    |                               suffix_decl_specified_scope star_ptr_operator cast_expression   
    |                               PLUS cast_expression
    |                               MINUS cast_expression
    |                               ESC cast_expression
    |                               SQUIGLY cast_expression
    |                               SIZEOF unary_expression
    |                               new_expression
    |                               global_scope new_expression
    |                               delete_expression
    |                               global_scope delete_expression;


delete_expression::=                DELETE cast_expression;                                  

new_expression::=                   NEW new_type_id new_initializer_opt
    |                               NEW parameters_clause new_type_id new_initializer_opt
    |                               NEW parameters_clause
    |                               NEW parameters_clause parameters_clause new_initializer_opt;
    
new_type_id::=                      type_specifier ptr_operator_seq_opt
    |                               type_specifier new_declarator
    |                               type_specifier new_type_id;
    
new_declarator::=                   ptr_operator new_declarator
    |                               direct_new_declarator;
    
direct_new_declarator::=            SQLPAREN expression SQRPAREN
    |                               direct_new_declarator SQLPAREN constant_expression SQRPAREN;
    
new_initializer_opt::=                /* empty */
    |                               LPAREN expression_list_opt RPAREN;


cast_expression::=                  unary_expression
    |                               abstract_expression cast_expression;

pm_expression::=                    cast_expression
    |                               pm_expression DOT_STAR cast_expression
    |                               pm_expression ARROW_STAR cast_expression;
    
multiplicative_expression::=        pm_expression
    |                               multiplicative_expression star_ptr_operator pm_expression
    |                               multiplicative_expression DIVIDE pm_expression
    |                               multiplicative_expression PERCENT pm_expression;
    
additive_expression::=              multiplicative_expression
    |                               additive_expression PLUS multiplicative_expression
    |                               additive_expression MINUS multiplicative_expression;
    
shift_expression::=                 additive_expression
    |                               shift_expression LEFTSHIFT additive_expression
    |                               shift_expression RIGHTSHIFT additive_expression;
   
relational_expression::=            shift_expression
    |                               relational_expression SMALLERTHAN shift_expression
    |                               relational_expression GREATERTHAN shift_expression
    |                               relational_expression LE shift_expression
    |                               relational_expression GE shift_expression;
    
equality_expression::=              relational_expression
    |                               equality_expression EQ relational_expression
    |                               equality_expression NE relational_expression;
    
and_expression::=                   equality_expression
    |                               and_expression AND equality_expression;
exclusive_or_expression::=          and_expression
    |                               exclusive_or_expression XOR and_expression;
inclusive_or_expression::=          exclusive_or_expression
    |                               inclusive_or_expression OR exclusive_or_expression;
logical_and_expression::=           inclusive_or_expression
    |                               logical_and_expression LOG_AND inclusive_or_expression;
logical_or_expression::=            logical_and_expression
    |                               logical_or_expression LOG_OR logical_and_expression;
conditional_expression::=           logical_or_expression
    |                               logical_or_expression QM expression COLON assignment_expression;


/*  assignment-expression is generalised to cover the simple assignment of a braced initializer in order to contribute to the
 *  coverage of parameter-declaration and init-declaration.
 */
assignment_expression::=            conditional_expression
    |                               logical_or_expression assignment_operator assignment_expression
    |                               logical_or_expression EQUAL braced_initializer
    |                               throw_expression;
assignment_operator::=              EQUAL | ASS_ADD | ASS_AND | ASS_DIV | ASS_MOD | ASS_MUL | ASS_OR | ASS_SHL | ASS_SHR | ASS_SUB | ASS_XOR;

/*  expression is widely used and usually single-element, so the reductions are arranged so that a
 *  single-element expression is returned as is. Multi-element expressions are parsed as a list that
 *  may then behave polymorphically as an element or be compacted to an element. */ 
expression_opt::=                    /* empty */
    |                               expression;
expression::=                       assignment_expression
    |                               expression_list COMMA assignment_expression;
constant_expression::=              conditional_expression;

/*  The grammar is repeated for when the parser stack knows that the next > must end a template.
 */
templated_relational_expression::=  shift_expression
    |                               templated_relational_expression SMALLERTHAN shift_expression
    |                               templated_relational_expression LE shift_expression
    |                               templated_relational_expression GE shift_expression;
templated_equality_expression::=    templated_relational_expression
    |                               templated_equality_expression EQ templated_relational_expression
    |                               templated_equality_expression NE templated_relational_expression;
templated_and_expression::=         templated_equality_expression
    |                               templated_and_expression AND templated_equality_expression;
templated_exclusive_or_expression::=templated_and_expression
    |                               templated_exclusive_or_expression XOR templated_and_expression;

templated_inclusive_or_expression::=templated_exclusive_or_expression
    |                               templated_inclusive_or_expression OR templated_exclusive_or_expression;

templated_logical_and_expression::= templated_inclusive_or_expression
    |                               templated_logical_and_expression LOG_AND templated_inclusive_or_expression;

templated_logical_or_expression::=  templated_logical_and_expression
    |                               templated_logical_or_expression LOG_OR templated_logical_and_expression;

templated_conditional_expression::= templated_logical_or_expression
    |                               templated_logical_or_expression QM templated_expression COLON templated_assignment_expression;

templated_assignment_expression::=  templated_conditional_expression
    |                               templated_logical_or_expression assignment_operator templated_assignment_expression
    |                               templated_throw_expression;
templated_expression::=             templated_assignment_expression
    |                               templated_expression_list COMMA templated_assignment_expression;

templated_expression_list::=        templated_assignment_expression
    |                               templated_expression_list COMMA templated_assignment_expression;

looping_statement::=                start_search looped_statement;       
                        /*{ end_search(); }*/
looped_statement::=                 statement
    |                               advance_search PLUS looped_statement
    |                               advance_search MINUS;
    
statement::=                        control_statement
    |                               compound_statement
    |                               declaration_statement
    |                               try_block;
    
control_statement::=                labeled_statement
    |                               selection_statement
    |                               iteration_statement
    |                               jump_statement;
    
labeled_statement::=                identifier COLON looping_statement
    |                               CASE constant_expression COLON looping_statement
    |                               DEFAULT COLON looping_statement;
    
compound_statement::=               CLPAREN statement_seq_opt CRPAREN
    |                               CLPAREN statement_seq_opt looping_statement HASHT bang error CRPAREN;  /*{ UNBANG("Bad statement-seq."); }*/
statement_seq_opt::=                 /* empty */
    |                               statement_seq_opt looping_statement
    |                               statement_seq_opt looping_statement HASHT bang error SEMI;      /*{ UNBANG("Bad statement."); }*/

selection_statement::=              IF LPAREN condition RPAREN looping_statement   
    |                               IF LPAREN condition RPAREN looping_statement ELSE looping_statement
    |                               SWITCH LPAREN condition RPAREN looping_statement;
    
condition_opt::=                     /* empty */
    |                               condition;
condition::=                        parameter_declaration_list;

iteration_statement::=              WHILE LPAREN condition RPAREN looping_statement
    |                               DO looping_statement WHILE LPAREN expression RPAREN SEMI
    |                               FOR LPAREN for_init_statement condition_opt SEMI expression_opt RPAREN looping_statement;

for_init_statement::=               simple_declaration;

jump_statement::=                   BREAK SEMI
    |                               CONTINUE SEMI
    |                               RETURN expression_opt SEMI
    |                               GOTO identifier SEMI;
    
declaration_statement::=             block_declaration;


compound_declaration::=             CLPAREN nest declaration_seq_opt CRPAREN                            /*{ unnest(); }*/
    |                               CLPAREN nest declaration_seq_opt util looping_declaration HASHT bang error CRPAREN;
                                                                                                /*{ unnest(); UNBANG("Bad declaration-seq."); }*/
declaration_seq_opt::=               /* empty */
    |                               declaration_seq_opt util looping_declaration
    |                               declaration_seq_opt util looping_declaration HASHT bang error SEMI; /*{ UNBANG("Bad declaration."); }*/
    
looping_declaration::=              start_search1 looped_declaration;                           /*{ end_search(); }*/

looped_declaration::=               declaration
    |                               advance_search PLUS looped_declaration
    |                               advance_search MINUS;
    
declaration::=                      block_declaration
    |                               function_definition
    |                               template_declaration
    |                               explicit_specialization
    |                               specialised_declaration;
    
specialised_declaration::=          linkage_specification
    |                               namespace_definition
    |                               TEMPLATE specialised_declaration;
    
block_declaration::=                simple_declaration
    |                               specialised_block_declaration;
    
specialised_block_declaration::=    asm_definition
    |                               namespace_alias_definition
    |                               using_declaration
    |                               using_directive
    |                               TEMPLATE specialised_block_declaration;
    
simple_declaration::=               SEMI
    |                               init_declaration SEMI
    |                               init_declarations SEMI
    |                               decl_specifier_prefix simple_declaration;

suffix_built_in_decl_specifier_raw::=built_in_type_specifier
    |                               suffix_built_in_decl_specifier_raw built_in_type_specifier
    |                               suffix_built_in_decl_specifier_raw decl_specifier_suffix;
    
suffix_built_in_decl_specifier::=   suffix_built_in_decl_specifier_raw
    |                               TEMPLATE suffix_built_in_decl_specifier;
    
suffix_named_decl_specifier::=      scoped_id
    |                               elaborate_type_specifier
    |                               suffix_named_decl_specifier decl_specifier_suffix;
suffix_named_decl_specifier_bi::=   suffix_named_decl_specifier
    |                               suffix_named_decl_specifier suffix_built_in_decl_specifier_raw;
  
suffix_named_decl_specifiers::=     suffix_named_decl_specifier_bi
    |                               suffix_named_decl_specifiers suffix_named_decl_specifier_bi;
    
suffix_named_decl_specifiers_sf::=  scoped_special_function_id          /* operators etc */
    |                               suffix_named_decl_specifiers
    |                               suffix_named_decl_specifiers scoped_special_function_id;
    
suffix_decl_specified_ids::=        suffix_built_in_decl_specifier
    |                               suffix_built_in_decl_specifier suffix_named_decl_specifiers_sf
    |                               suffix_named_decl_specifiers_sf;
    
suffix_decl_specified_scope::=      suffix_named_decl_specifiers SCOPE
    |                               suffix_built_in_decl_specifier suffix_named_decl_specifiers SCOPE
    |                               suffix_built_in_decl_specifier SCOPE;

decl_specifier_affix::=              storage_class_specifier
    |                               function_specifier
    |                               FRIEND                                                          
    |                               TYPEDEF
    |                               cv_qualifier;

decl_specifier_suffix::=             decl_specifier_affix;

decl_specifier_prefix::=            decl_specifier_affix
    |                               TEMPLATE decl_specifier_prefix;

storage_class_specifier::=          REGISTER | STATIC | MUTABLE
    |                               EXTERN                  
    |                               AUTO;

function_specifier::=               EXPLICIT
    |                               INLINE
    |                               VIRTUAL;

type_specifier::=                   simple_type_specifier
    |                               elaborate_type_specifier
    |                               cv_qualifier;

elaborate_type_specifier::=         class_specifier
    |                               enum_specifier
    |                               elaborated_type_specifier
    |                               TEMPLATE elaborate_type_specifier;
    
simple_type_specifier::=            scoped_id
    |                               built_in_type_specifier;
    
built_in_type_specifier::=          CHAR | BOOLEAN | SHORT | INT | LONG | SIGNED | UNSIGNED | FLOAT | DOUBLE | VOID;


elaborated_type_specifier::=        elaborated_class_specifier
    |                               elaborated_enum_specifier
    |                               TYPENAME scoped_id;

elaborated_enum_specifier::=        ENUM scoped_id;

enum_specifier::=                   ENUM scoped_id enumerator_clause
    |                               ENUM enumerator_clause;
    
enumerator_clause::=                CLPAREN enumerator_list_ecarb
    |                               CLPAREN enumerator_list enumerator_list_ecarb
    |                               CLPAREN enumerator_list COMMA enumerator_definition_ecarb;
    
enumerator_list_ecarb::=            CRPAREN
    |                               bang error CRPAREN;                                              /*{ UNBANG("Bad enumerator-list."); }*/
    
enumerator_definition_ecarb::=      CRPAREN
    |                               bang error CRPAREN;                                             /*{ UNBANG("Bad enumerator-definition."); }*/
    
enumerator_definition_filler::=      /* empty */
    |                               bang error COMMA;                                              /*{ UNBANG("Bad enumerator-definition."); }*/
    
enumerator_list_head::=             enumerator_definition_filler
    |                               enumerator_list COMMA enumerator_definition_filler;
    
enumerator_list::=                  enumerator_list_head enumerator_definition;

enumerator_definition::=            enumerator
    |                               enumerator EQUAL constant_expression;
    
enumerator::=                       identifier;

namespace_definition::=             NAMESPACE scoped_id compound_declaration
    |                               NAMESPACE compound_declaration;
    
namespace_alias_definition::=       NAMESPACE scoped_id EQUAL scoped_id SEMI;

using_declaration::=                USING declarator_id SEMI
    |                               USING TYPENAME declarator_id SEMI;

using_directive::=                  USING NAMESPACE scoped_id SEMI;

asm_definition::=                   ASM LPAREN string RPAREN SEMI;

linkage_specification::=            EXTERN string looping_declaration
    |                               EXTERN string compound_declaration;

init_declarations::=                assignment_expression COMMA init_declaration
    |                               init_declarations COMMA init_declaration;
    
init_declaration::=                 assignment_expression;



star_ptr_operator::=                TIMES
    |                               star_ptr_operator cv_qualifier;
    
nested_ptr_operator::=              star_ptr_operator
    |                               id_scope nested_ptr_operator;
    
ptr_operator::=                     AND
    |                               nested_ptr_operator
    |                               global_scope nested_ptr_operator;
    
ptr_operator_seq::=                 ptr_operator
    |                               ptr_operator ptr_operator_seq;
    
ptr_operator_seq_opt::=              /* empty */                        
    |                               ptr_operator ptr_operator_seq_opt;

cv_qualifier_seq_opt::=              /* empty */
    |                               cv_qualifier_seq_opt cv_qualifier;
    
cv_qualifier::=                     CONST | VOLATILE;

type_id::=                          type_specifier abstract_declarator_opt
    |                               type_specifier type_id;

abstract_declarator_opt::=           /* empty */
    |                               ptr_operator abstract_declarator_opt
    |                               direct_abstract_declarator;
    
direct_abstract_declarator_opt::=    /* empty */
    |                               direct_abstract_declarator;
    
direct_abstract_declarator::=       direct_abstract_declarator_opt parenthesis_clause
    |                               direct_abstract_declarator_opt SQLPAREN SQRPAREN
    |                               direct_abstract_declarator_opt SQLPAREN constant_expression SQRPAREN;

parenthesis_clause::=               parameters_clause cv_qualifier_seq_opt
    |                               parameters_clause cv_qualifier_seq_opt exception_specification;
    
parameters_clause::=                 LPAREN parameter_declaration_clause RPAREN;

parameter_declaration_clause::=      /* empty */
    |                               parameter_declaration_list
    |                               parameter_declaration_list ELLIPSIS;
    
parameter_declaration_list::=       parameter_declaration
    |                               parameter_declaration_list COMMA parameter_declaration;


abstract_pointer_declaration::=     ptr_operator_seq
    |                               multiplicative_expression star_ptr_operator ptr_operator_seq_opt;
    
abstract_parameter_declaration::=   abstract_pointer_declaration
    |                               and_expression AND
    |                               and_expression AND abstract_pointer_declaration;
    
special_parameter_declaration::=    abstract_parameter_declaration
    |                               abstract_parameter_declaration EQUAL assignment_expression
    |                               ELLIPSIS;
    
parameter_declaration::=            assignment_expression
    |                               special_parameter_declaration
    |                               decl_specifier_prefix parameter_declaration;

templated_parameter_declaration::=  templated_assignment_expression
    |                               templated_abstract_declaration
    |                               templated_abstract_declaration EQUAL templated_assignment_expression
    |                               decl_specifier_prefix templated_parameter_declaration;
    
templated_abstract_declaration::=    abstract_pointer_declaration
    |                               templated_and_expression AND
    |                               templated_and_expression AND abstract_pointer_declaration;


function_definition::=              ctor_definition
    |                               func_definition;
    
func_definition::=                  assignment_expression function_try_block
    |                               assignment_expression function_body
    |                               decl_specifier_prefix func_definition;
    
ctor_definition::=                  constructor_head function_try_block
    |                               constructor_head function_body
    |                               decl_specifier_prefix ctor_definition;
    
constructor_head::=                 bit_field_init_declaration
    |                               constructor_head COMMA assignment_expression;
    
function_try_block::=               TRY function_block handler_seq;

function_block::=                   ctor_initializer_opt function_body;

function_body::=                    compound_statement;

initializer_clause::=               assignment_expression
    |                               braced_initializer;
    
braced_initializer::=               CLPAREN initializer_list CRPAREN
    |                               CLPAREN initializer_list COMMA CRPAREN
    |                               CLPAREN CRPAREN
    |                               CLPAREN looping_initializer_clause HASHT bang error CRPAREN           /*{ UNBANG("Bad initializer_clause."); }*/
    |                               CLPAREN initializer_list COMMA looping_initializer_clause HASHT bang error CRPAREN;
                                                                                                /*{ UNBANG("Bad initializer_clause."); }*/
initializer_list::=                 looping_initializer_clause
    |                               initializer_list COMMA looping_initializer_clause;
    
looping_initializer_clause::=       start_search looped_initializer_clause;                      /*{ end_search(); }*/

looped_initializer_clause::=        initializer_clause
    |                               advance_search PLUS looped_initializer_clause
    |                               advance_search MINUS;


colon_mark::=                       COLON;                                                         /*{ mark(); };*/

class_key::=                        CLASS | STRUCT | UNION;

elaborated_class_specifier::=       class_key scoped_id                    
    |                               class_key scoped_id colon_mark error;                        /*{ rewind_colon(); }*/
    
class_specifier_head::=             class_key scoped_id colon_mark base_specifier_list CLPAREN      /*{ unmark(); }*/
    |                               class_key COLON base_specifier_list CLPAREN
    |                               class_key scoped_id CLPAREN
    |                               class_key CLPAREN; 

class_specifier::=                  class_specifier_head member_specification_opt CRPAREN
    |                               class_specifier_head member_specification_opt util looping_member_declaration HASHT bang error CRPAREN;
                                            /*{ UNBANG("Bad member_specification_opt."); }*/
member_specification_opt::=          /* empty */
    |                               member_specification_opt util looping_member_declaration
    |                               member_specification_opt util looping_member_declaration HASHT bang error SEMI;
                                                                                                /*{ UNBANG("Bad member-declaration."); }*/
looping_member_declaration::=       start_search looped_member_declaration;                      /*{ end_search(); }*/

looped_member_declaration::=        member_declaration
    |                               advance_search PLUS looped_member_declaration
    |                               advance_search MINUS;
    
member_declaration::=               accessibility_specifier
    |                               simple_member_declaration
    |                               function_definition
    |                               using_declaration
    |                               template_declaration;

simple_member_declaration::=        SEMI
    |                               assignment_expression SEMI
    |                               constructor_head SEMI
    |                               member_init_declarations SEMI
    |                               decl_specifier_prefix simple_member_declaration;
    
member_init_declarations::=         assignment_expression COMMA member_init_declaration
    |                               constructor_head COMMA bit_field_init_declaration
    |                               member_init_declarations COMMA member_init_declaration;
    
member_init_declaration::=          assignment_expression
    |                               bit_field_init_declaration;
    
accessibility_specifier::=          access_specifier COLON;

bit_field_declaration::=            assignment_expression COLON bit_field_width
    |                               COLON bit_field_width;
    
bit_field_width::=                  logical_or_expression
    |                               logical_or_expression QM bit_field_width COLON bit_field_width;
    
bit_field_init_declaration::=       bit_field_declaration
    |                               bit_field_declaration EQUAL initializer_clause;

base_specifier_list::=              base_specifier
    |                               base_specifier_list COMMA base_specifier;
    
base_specifier::=                   scoped_id
    |                               access_specifier base_specifier
    |                               VIRTUAL base_specifier;
    
access_specifier::=                 PRIVATE | PROTECTED | PUBLIC;


conversion_function_id::=           OPERATOR conversion_type_id;

conversion_type_id::=               type_specifier ptr_operator_seq_opt
    |                               type_specifier conversion_type_id;

ctor_initializer_opt::=              /* empty */
    |                               ctor_initializer;
    
ctor_initializer::=                 COLON mem_initializer_list
    |                               COLON mem_initializer_list bang error;                         /*{ UNBANG("Bad ctor-initializer."); }*/
    
mem_initializer_list::=             mem_initializer
    |                               mem_initializer_list_head mem_initializer;
 
mem_initializer_list_head::=        mem_initializer_list COMMA
    |                               mem_initializer_list bang error COMMA;                         /*{ UNBANG("Bad mem-initializer."); }*/
    
mem_initializer::=                  mem_initializer_id LPAREN expression_list_opt RPAREN;

mem_initializer_id::=               scoped_id;

operator_function_id::=             OPERATOR operator;

operator::=            /*++++*/     NEW
    |                 /*++++*/      DELETE
    |                               PLUS
    |                               MINUS
    |                               TIMES
    |                               DIVIDE
    |                               PERCENT
    |                               XOR
    |                               AND
    |                               OR
    |                               SQUIGLY
    |                               ESC
    |                               EQUAL
    |                               SMALLERTHAN
    |                               GREATERTHAN
    |                               ASS_ADD
    |                               ASS_SUB
    |                               ASS_MUL
    |                               ASS_DIV
    |                               ASS_MOD
    |                               ASS_XOR
    |                               ASS_AND
    |                               ASS_OR
    |                               LEFTSHIFT
    |                               RIGHTSHIFT
    |                               ASS_SHR
    |                               ASS_SHL
    |                               EQ
    |                               NE
    |                               LE
    |                               GE
    |                               LOG_AND
    |                               LOG_OR
    |                               INC
    |                               DEC
    |                               COMMA
    |                               ARROW_STAR
    |                               ARROW
    |                               LPAREN RPAREN
    |                               SQLPAREN SQRPAREN;

template_declaration::=             template_parameter_clause declaration
    |                               EXPORT template_declaration;
    
template_parameter_clause::=        TEMPLATE SMALLERTHAN template_parameter_list GREATERTHAN;

template_parameter_list::=          template_parameter
    |                               template_parameter_list COMMA template_parameter;
    
template_parameter::=               simple_type_parameter
    |                               simple_type_parameter EQUAL type_id
    |                               templated_type_parameter
    |                               templated_type_parameter EQUAL identifier
    |                               templated_parameter_declaration
    |                               bang error;                                                  /*{ UNBANG("Bad template-parameter."); }*/
    
simple_type_parameter::=            CLASS
    |                               TYPENAME;
    
templated_type_parameter::=         template_parameter_clause CLASS
    |                               template_parameter_clause CLASS identifier;
    
template_id::=                      TEMPLATE identifier SMALLERTHAN template_argument_list GREATERTHAN
    |                               TEMPLATE template_id;

template_argument_list::=           template_argument
    |                               template_argument_list COMMA template_argument;
    
template_argument::=                templated_parameter_declaration;

explicit_specialization::=          TEMPLATE SMALLERTHAN GREATERTHAN declaration;


try_block::=                        TRY compound_statement handler_seq;

handler_seq::=                      handler
    |                               handler handler_seq;
    
handler::=                          CATCH LPAREN exception_declaration RPAREN compound_statement;

exception_declaration::=            parameter_declaration;

throw_expression::=                 THROW
    |                               THROW assignment_expression;
    
templated_throw_expression::=       THROW
    |                               THROW templated_assignment_expression;

exception_specification::=          THROW LPAREN RPAREN
    |                               THROW LPAREN type_id_list RPAREN;
    
type_id_list::=                     type_id
    |                               type_id_list COMMA type_id;

/*---------------------------------------------------------------------------------------------------
 * Back-tracking and context support
 *---------------------------------------------------------------------------------------------------*/
advance_search::=                    error;               /*{ yyerrok; yyclearin; advance_search(); }*/ /* Rewind and queue PLUS or MINUS HASHT */       
bang::=                              /* empty */;         /*{ BANG(); }*/   /* set flag to suppress "parse error" */ 
mark::=                              /* empty */         /*{ mark(); }*/ ;       /* Push lookahead and input token stream context onto a stack */
nest::=                              /* empty */ ;        /*{ nest(); }*/        /* Push a declaration nesting depth onto the parse stack */
start_search::=                      /* empty */ ;        /*{ start_search(false); }*/    /* Create/reset binary search context */
start_search1::=                     /* empty */ ;        /*{ start_search(true); }*/     /* Create/reset binary search context */
util::=                              /* empty */ ;          /* Get current utility mode */


			